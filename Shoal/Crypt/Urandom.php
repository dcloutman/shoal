<?php
/**
 * \Shoal\Crypt\Urandom
 * @author David Cloutman
 * @package \Shoal\Crypt
 * @license MIT
 */

namespace Shoal\Crypt;

/**
 * This is a singleton class that generates random values from a filestream from /dev/urandom. These values
 * are more cryptographically secure that values generated by the rand() function or from /dev/random.
 */
class Urandom {
    /**
     * @var \Shoal\Util\Urandom $instance The single instance of this class.
     * @internal
     */
    private static $instance = null;

    /**
     * @var resource $instance The file resource pointing to /dev/urandom.
     * @internal
     */
    protected $urandomRsc = null;

    /**
     * Opens /dev/urandom if not already open.
     * @deprecated 0.4.0 Use openURandom() method.
     * @see Urandom::openUrandom();
     */
    public function open_urandom () {
        $this->openUrandom();
    }

    /**
     * Opens /dev/urandom if not already open.
     */
    public function openUrandom () {
        if (null === $this->urandomRsc || !is_resource($this->urandomRsc)) {
            $this->urandomRsc = fopen('/dev/urandom', 'rb');
        }
    }


    /**
     * Returns the current handle for /dev/urandom.
     * @return resource
     * @deprecated v0.4.0 Use getUrandomRsc() method.
     * @see Urandom::getUrandomRsc()
     */
    public function get_urandom_rsc () {
        return $this->getUrandomRsc();
    }

    /**
     * Returns the current handle for /dev/urandom.
     * @return resource
     */
    public function getUrandomRsc () {
        return $this->urandomRsc;
    }


    /**
     * Gets a random stream of binary values.
     * @param integer $length The number of bytes read. Default is 4096.
     * @return string A stream of random binary values.
     * @deprecated 0.4.0 Use getBinaryStream() method.
     * @see Urandom::getBinaryStream()
     */
    public function get_binary_stream ($length = 4096) {
        return $this->getBinaryStream($length);
    }

    /**
     * Gets a random stream of binary values.
     * @param integer $length The number of bytes read. Default is 4096.
     * @return string A stream of random binary values.
     */
    public function getBinaryStream ($length = 4096) {
        $randomBinary = fread($this->urandomRsc, $length);
        return $randomBinary;
    }

    /**
     * Generates a random base64 encoded string based off a /dev/urandom binary string.
     * @param integer $streamLength Default is 4096 bytes. Longer binary streams produce longer, and thus more secure, base64 strings, but take longer to generate.
     * @return string
     * @deprecated v0.4.0 Use getRandomBase64String() method.
     * @see Urandom::getRandomBase64String()
     */
    public function get_random_base64_string ($streamLength = 4096) {
        return $this->getRandomBase64String($streamLength);
    }

    /**
     * Generates a random base64 encoded string based off a /dev/urandom binary string.
     * @param integer $streamLength Default is 4096 bytes. Longer binary streams produce longer, and thus more secure, base64 strings, but take longer to generate.
     * @return string
     */
    public function getRandomBase64String ($streamLength = 4096) {
        return base64_encode($this->getBinaryStream($streamLength));
    }

    /**
     * Generates a random sha1 hash based off a /dev/urandom binary string.
     * @param integer $streamLength Default is 4096 bytes. Longer binary streams have more possible sha1 values but take longer to generate.
     * @deprecated 0.4.0 Use getRandomSha1() method.
     * @see Urandom::getRandomSha1()
     */
    public function get_random_sha1 ($streamLength = 4096) {
        return $this->getRandomSha1();
    }

    /**
     * Generates a random sha1 hash based off a /dev/urandom binary string.
     * @param integer $streamLength Default is 4096 bytes. Longer binary streams have more possible sha1 values but take longer to generate.
     */
    public function getRandomSha1 ($streamLength = 4096) {
        return sha1($this->getBinaryStream($streamLength));
    }

    /**
     * Generates a random md5 hash based off a /dev/urandom binary string.
     * @param integer $streamLength Default is 4096 bytes. Longer binary streams have more possible md5 values but take longer to generate.
     * @deprecated 0.4.0 Use getRandomMd5() method
     * @see Urandom::getRandomMd5()
     */
    public function get_random_md5 ($streamLength = 4096) {
        return $this->getRandomMd5($streamLength);
    }

    /**
     * Generates a random md5 hash based off a /dev/urandom binary string.
     * @param integer $streamLength Default is 4096 bytes. Longer binary streams have more possible md5 values but take longer to generate.
     */
    public function getRandomMd5 ($streamLength = 4096) {
        return md5($this->getBinaryStream($streamLength));
    }

    /**
     * Generates a random string of text from a subset of the lower 127 characters of the ASCII character set without whitespace, control characters,
     * escape sequences, interpolotation characters or valid HTML or XML tags. The resulting text has higher entropy than the results of
     * getRandomBase64String, but is more computationally expensive. A range of acceptable lengths for the desired text must be specified.
     * A fixed length of 32 characters is the default length.
     * @param integer $minLength Range inclusive.
     * @param integer $maxLength Range inclusive.
     * @return string
     */
    public function getRandomText ($minLength = 32, $maxLength = 32) {
        // Bans characters that could cause data injections or unintended encodings.
        $charBlacklist = ['$', '"', '\'', '{', '\\', '<', '>', '%', '&'];

        // Build list. Shuffle to add a little non-cryptographic quality noise.
        $validChars = [];
        for ($i = 33; $i <= 126; $i++) {
            $validCharsMember = chr($i);
            if (false !== array_search($newChar, $charBlacklist, true)) continue;

            $validChars[] = $validCharsMember;
            shuffle($validChars);
        }
        shuffle($validChars);

        $validCharsLength = len($validChars);


        $finalTextLength = mt_rand($minLength, $maxLength);

        // Introduce cryptographic quality randomness via an array of 32 bit unsigned integers with the same length as the random text.
        $randomNums = unpack('L', $this->getBinaryStream($finalTextLength * 4));

        if (count($randomNums) != $finalTextLength) throw new \Exception('FCK\'d');

        // Generate text.
        $randomText = '';
        for ($i = 0; $i < $finalTextLength; $i++) {
            // random_number % card = random_index
            $randomIndex = $randomNums[$i] % $validCharsLength;
            $newChar = $validChars[$randomIndex];
            $randomText = (bool) mt_rand(0, 1) ? $randomText . $newChar : $newChar . $randomText;
            shuffle($validChars); // Decreases modulus bias.
        }

        return $randomText;
    }

    /**
     * This class may only instantiate itself.
     * @internal
     */
    private function __construct () {
        $this->openUrandom();
    }

    /**
     * Returns the single instance of the lampfire\util\Urandom class.
     * @deprecated 0.4.0 Use getInstance() method.
     * @see Urandom::getInstance()
     */
    public static function get_instance() {
        return self::getInstance();
    }

    /**
     * Returns the single instance of the lampfire\util\Urandom class.
     */
    public static function getInstance() {
        if (null === self::$instance) {
            self::$instance = new self();
        }

        self::$instance->openUrandom(); // Ensure that urandom is open each time the singleton is requested.
        return self::$instance;
    }


    /**
     * You may not clone a singleton.
     * @internal
     */
    private function __clone () {}
}


